snippet class
	class ${1:`Filename('', 'UNTITLED')`} {
		public:
			$1();
			~$1();
		private:
			${2:/* data */}
	};
snippet u
	using namespace std;
snippet fg
	#ifndef ${1:`toupper(Filename('', 'UNTITLED'))`}
	#define $1

	${2:/* data */}

	#endif /* end of $1 */
snippet try
	try {
		${1:/* code */}
	} catch(...) {
		${2:/* handle exception */}
	}
snippet code
	#include      <algorithm>
	#include      <cmath>
	#include      <cstdarg>
	#include      <cstdio>
	#include      <cstdlib>
	#include      <iomanip>
	#include      <iostream>
	#include      <iterator>
	#include      <limits>
	#include      <list>
	#include      <map>
	#include      <set>
	#include      <vector>
	#define endl '\n'
	#define each(c, e) for (typeof(c.begin()) e = c.begin(); e != c.end(); ++e)
	typedef long long ll;
	using namespace std;
	int main(int argc, char **argv) {
		ios_base::sync_with_stdio(false), cin.tie(0);
		${1:/* code */}
		return 0;
	}
snippet math
	template<typename T> inline T ceilDiv(T l, T r) {return (l / r) + ((l % r) != 0);}
	const int oo = numeric_limits<int>::max();
snippet codeprinter
	template<typename T1, typename T2> ostream& operator<<(ostream &o, const pair<T1, T2> &p) {return o << '(' << p.first << ", " << p.second << ')';}
	template<typename I> ostream& print(ostream &o, I s, I e, int w = 5, int prec = 2, const string &sep = ", ", const string &lhs = "", const string &rhs = "") {
		o << lhs;
		if (s != e) o << setw(w) << setprecision(prec) << *(s++);
		for (; s != e; ++s) o << sep << setw(w) << setprecision(prec) << *s;
		return o << rhs;
	}
	template<typename T, template<typename E, typename A=std::allocator<E> > class C>
	ostream& operator<<(ostream &o, const C<T>& c) {return print(o, c.begin(), c.end(), 0, 2, ", ", "[", "]");}
	template<typename T, template<typename E, typename Compare = less<E>, typename Alloc = allocator<E> > class C>
	ostream& operator<<(ostream &o, const C<T>& c) {return print(o, c.begin(), c.end(), 0, 2, ", ", "{", "}");}
	template<typename K, typename T, template<typename E1, typename E2, typename Compare = std::less<E1>, class Allocator = std::allocator<std::pair<const E1, E2> > > class C>
	ostream& operator<<(ostream &o, const C<K, T>& c) {return print(o, c.begin(), c.end(), 0, 2, ", ", "{", "}");}
snippet codereader
	const int BUFF_SIZE = 1024 * 256;
	char g_rbuffer[BUFF_SIZE], *g_rpos = g_rbuffer, *g_rend = g_rbuffer;
	#define READ_HELPER(fnAccum, fnEnd, fnCheck) while (true) { for (; g_rpos != g_rend && (fnCheck); ++g_rpos) fnAccum;\
		if (g_rpos != g_rend) fnEnd; g_rend = g_rbuffer + read(0, g_rbuffer, BUFF_SIZE), g_rpos = g_rbuffer; }
	template<typename R> void readNumber(R &rtn) {
		rtn = 0;
		READ_HELPER(;, break, *g_rpos < '0' || *g_rpos > '9'); READ_HELPER(rtn = rtn * 10 + *g_rpos - '0', return, *g_rpos >= '0' && *g_rpos <= '9');
	}
snippet codewriter
	char g_wbuffer[BUFF_SIZE];
	char *g_wpos = g_wbuffer, *g_wend = g_wbuffer + BUFF_SIZE;
	inline void flushWBuffer() { write(1, g_wbuffer, g_wpos - g_wbuffer); g_wpos = g_wbuffer;}
	inline void writeChar(char ch) { *(g_wpos++) = ch; if (g_wpos == g_wend) flushWBuffer(); }
	void writeBuffer(char *start, char *end) { for (; start != end; start += 1) writeChar(*start); }
	template<typename I> void writeNumber(I n) {
		static char tmpBuffer[100];
		char *cur = tmpBuffer, *start = tmpBuffer;
		if (n == 0) { writeChar('0'); return; }
		if (n < 0) *(cur++) = '-', n *= -1, start += 1;
		while (n) *(cur++) = n % 10 + '0', n /= 10;
		reverse(start, cur); writeBuffer(tmpBuffer, cur);
	}
snippet codejobs
	#include      <pthread.h>
	#include      <unistd.h>
	#include      <queue>
	template<typename T> class JobQueue {
		private:
			queue<T> m_queueJobs;
			pthread_mutex_t m_lock;
		public:
			JobQueue() { pthread_mutex_init(&m_lock, NULL); }
			~JobQueue() { pthread_mutex_destroy(&m_lock); }
			void addJob(const T &job) {
				pthread_mutex_lock(&m_lock); m_queueJobs.push(job); pthread_mutex_unlock(&m_lock);
			}
			bool getJob(T &job, int nWaitInterval = -1) {
				bool bGot = false;
				while (true) {
					pthread_mutex_lock(&m_lock);
					if (!m_queueJobs.empty()) { job = m_queueJobs.front(); m_queueJobs.pop(); bGot = true; }
					pthread_mutex_unlock(&m_lock);
					if (bGot) return true;
					else if (nWaitInterval != -1) sleep(nWaitInterval);
					else return false;
				}
			}
			int jobCount() {
				int cnt = 0;
				pthread_mutex_lock(&m_lock); cnt = m_queueJobs.size(); pthread_mutex_unlock(&m_lock);
				return cnt;
			}
			void getAll(queue<T> &queueJobs) { pthread_mutex_lock(&m_lock); queueJobs = m_queueJobs; pthread_mutex_unlock(&m_lock); }
	};
	// void* solve(void*) {}
	// for (int t = 1; t <= THREADS; t += 1) { pthread_t thread; pthread_create(&thread, NULL, solve, NULL); }
